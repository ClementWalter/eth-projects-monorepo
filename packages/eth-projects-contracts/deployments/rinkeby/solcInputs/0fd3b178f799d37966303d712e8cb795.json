{
  "language": "Solidity",
  "sources": {
    "contracts/lib/renderers/RectEncoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport {Array} from \"../utils/Array.sol\";\n\nerror CoordinatesOutOfRange(uint256 coordinate);\n\nstruct Rect {\n    uint32 x;\n    uint32 y;\n    uint32 width;\n    uint32 height;\n    uint32 fillIndex;\n}\n\nstruct Trait {\n    Rect[] rects;\n    string name;\n}\n\nstruct TraitEncoded {\n    bytes rects;\n    string name;\n}\n\nstruct Characteristic {\n    Trait[] traits;\n    string name;\n}\n\nstruct CharacteristicEncoded {\n    bytes traits;\n    string[] names;\n    string name;\n}\n\nstruct Collection {\n    Characteristic[] characteristics;\n    string description;\n}\n\nstruct CollectionEncoded {\n    bytes traits;\n    string[][] traitNames;\n    string[] characteristicNames;\n    string description;\n}\n\n/**  @title RectEncoder\n *\n *   This library can be used (off-chain !) to encode a collection to be deployed and render on-chain images with the\n *   RectRenderer.\n *\n * @author Clement Walter <clement0walter@gmail.com>\n */\ncontract RectEncoder {\n    using Array for string[];\n    using Array for bytes[];\n    using Array for uint16[];\n    using Array for bytes4[];\n\n    /** @dev Use this function to encode a single <rect> as expected by the renderer. Use this off-chain!\n     *\n     * @param rect The <rect> to encode\n     * @return The encoded rectangle as a bytes4\n     */\n    function encodeRect(Rect memory rect) public pure returns (bytes4) {\n        // each coordinates should use only 6 bits and is consequently stored like 00nnnnnn\n        if (rect.x > 63) revert CoordinatesOutOfRange(rect.x);\n        if (rect.y > 63) revert CoordinatesOutOfRange(rect.y);\n        if (rect.width > 63) revert CoordinatesOutOfRange(rect.width);\n        if (rect.height > 63) revert CoordinatesOutOfRange(rect.height);\n        return\n            bytes4(rect.x << 26) |\n            bytes4(rect.y << 20) |\n            bytes4(rect.width << 14) |\n            bytes4(rect.height << 8) |\n            bytes4(rect.fillIndex);\n    }\n\n    /** @dev Use this function to encode a _trait_, i.e. a list of <rect>s with a name, as expected by the renderer.\n     *       Use this off-chain!\n     *\n     * @param trait The list of <rect>s to encode with a given name; should be shorter than 32 char.\n     * @return The encoded list of rectangle\n     */\n    function encodeTrait(Trait memory trait)\n        public\n        pure\n        returns (TraitEncoded memory)\n    {\n        bytes4[] memory rects = new bytes4[](trait.rects.length);\n        for (uint256 i = 0; i < trait.rects.length; i++) {\n            rects[i] = encodeRect(trait.rects[i]);\n        }\n        return TraitEncoded(rects.join(), trait.name);\n    }\n\n    /** @dev Use this function to encode a characteristic, i.e. a list of traits belongings to the same group. Note that\n     *       there is no intrinsic difference between a characteristic and a whole collection (all the traits of all the\n     *       characteristics) but it's how it's used and expected today so we keep the wording here.\n     *       Use this off-chain and push the result using RendererCommon.storeBytes\n     *  @param characteristic The list of Trait constituting the characteristic.\n     *  @return The encoded characteristic (mainly a bytes memory whose encoding somehow follows solidity memory storage rules.)\n     */\n    function encodeCharacteristic(Characteristic memory characteristic)\n        public\n        pure\n        returns (CharacteristicEncoded memory)\n    {\n        bytes[] memory rects = new bytes[](characteristic.traits.length);\n        string[] memory names = new string[](characteristic.traits.length);\n        uint16[] memory lengths = new uint16[](\n            characteristic.traits.length + 1\n        );\n        uint16 cumSum = 4 +\n            2 *\n            uint16(characteristic.traits.length % type(uint16).max); // 2 extra bytes for storing start & end for each trait\n        for (uint256 i = 0; i < characteristic.traits.length; i++) {\n            TraitEncoded memory tmp = encodeTrait(characteristic.traits[i]);\n            rects[i] = tmp.rects;\n            names[i] = tmp.name;\n            lengths[i] = cumSum;\n            cumSum += uint16(rects[i].length % type(uint16).max);\n        }\n        lengths[characteristic.traits.length] = cumSum;\n        return (\n            CharacteristicEncoded(\n                bytes.concat(\n                    bytes2(\n                        uint16(\n                            (characteristic.traits.length + 1) %\n                                type(uint16).max\n                        )\n                    ),\n                    lengths.join(),\n                    rects.join()\n                ),\n                names,\n                characteristic.name\n            )\n        );\n    }\n\n    /** @dev Use this function to encode a full collection, i.e. a list of characteristics.\n     *       Use this off-chain and push the result using RendererCommon.storeBytes\n     *\n     * @param collection The list of Characteristic constituting the collection. The description is just returned in the\n     *        new object and can be used to store the description of the collection.\n     * @return The encoded collection (mainly a bytes memory whose encoding somehow follows solidity memory storage rules.)\n     */\n    function encodeCollection(Collection memory collection)\n        public\n        pure\n        returns (CollectionEncoded memory)\n    {\n        bytes[] memory traits = new bytes[](collection.characteristics.length);\n        string[] memory characteristicNames = new string[](\n            collection.characteristics.length\n        );\n        string[][] memory traitNames = new string[][](\n            collection.characteristics.length\n        );\n        uint16[] memory lengths = new uint16[](\n            collection.characteristics.length\n        );\n        // init characteristic pointer shift with 2 bytes for length + 2 bytes per characteristic\n        uint16 cumSum = 2 +\n            2 *\n            uint16(collection.characteristics.length % type(uint16).max);\n        for (uint256 i = 0; i < collection.characteristics.length; i++) {\n            CharacteristicEncoded memory tmp = encodeCharacteristic(\n                collection.characteristics[i]\n            );\n            lengths[i] = cumSum;\n            traits[i] = tmp.traits;\n            traitNames[i] = tmp.names;\n            characteristicNames[i] = tmp.name;\n            cumSum += uint16(traits[i].length % type(uint16).max);\n        }\n        return (\n            CollectionEncoded(\n                bytes.concat(\n                    bytes2(\n                        uint16(\n                            collection.characteristics.length % type(uint16).max\n                        )\n                    ),\n                    lengths.join(),\n                    traits.join()\n                ),\n                traitNames,\n                characteristicNames,\n                collection.description\n            )\n        );\n    }\n}\n"
    },
    "contracts/lib/utils/Array.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/*\n * @title Arrays Utils\n * @author Clement Walter <clement0walter@gmail.com>\n *\n * @notice An attempt at implementing some of the widely used javascript's Array functions in solidity.\n */\npragma solidity ^0.8.12;\n\nerror EmptyArray();\nerror GlueOutOfBounds(uint256 length);\n\nlibrary Array {\n    function join(string[] memory a, string memory glue)\n        public\n        pure\n        returns (string memory)\n    {\n        uint256 inputPointer;\n        uint256 gluePointer;\n\n        assembly {\n            inputPointer := a\n            gluePointer := glue\n        }\n        return string(_joinReferenceType(inputPointer, gluePointer));\n    }\n\n    function join(string[] memory a) public pure returns (string memory) {\n        return join(a, \"\");\n    }\n\n    function join(bytes[] memory a, bytes memory glue)\n        public\n        pure\n        returns (bytes memory)\n    {\n        uint256 inputPointer;\n        uint256 gluePointer;\n\n        assembly {\n            inputPointer := a\n            gluePointer := glue\n        }\n        return _joinReferenceType(inputPointer, gluePointer);\n    }\n\n    function join(bytes[] memory a) public pure returns (bytes memory) {\n        return join(a, bytes(\"\"));\n    }\n\n    function join(bytes2[] memory a) public pure returns (bytes memory) {\n        uint256 pointer;\n\n        assembly {\n            pointer := a\n        }\n        return _joinValueType(pointer, 2, 0);\n    }\n\n    /// @dev Join the underlying array of bytes2 to a string.\n    function join(uint16[] memory a) public pure returns (bytes memory) {\n        uint256 pointer;\n\n        assembly {\n            pointer := a\n        }\n        return _joinValueType(pointer, 2, 256 - 16);\n    }\n\n    function join(bytes3[] memory a) public pure returns (bytes memory) {\n        uint256 pointer;\n\n        assembly {\n            pointer := a\n        }\n        return _joinValueType(pointer, 3, 0);\n    }\n\n    function join(bytes4[] memory a) public pure returns (bytes memory) {\n        uint256 pointer;\n\n        assembly {\n            pointer := a\n        }\n        return _joinValueType(pointer, 4, 0);\n    }\n\n    function join(bytes8[] memory a) public pure returns (bytes memory) {\n        uint256 pointer;\n\n        assembly {\n            pointer := a\n        }\n        return _joinValueType(pointer, 8, 0);\n    }\n\n    function join(bytes16[] memory a) public pure returns (bytes memory) {\n        uint256 pointer;\n\n        assembly {\n            pointer := a\n        }\n        return _joinValueType(pointer, 16, 0);\n    }\n\n    function join(bytes32[] memory a) public pure returns (bytes memory) {\n        uint256 pointer;\n\n        assembly {\n            pointer := a\n        }\n        return _joinValueType(pointer, 32, 0);\n    }\n\n    function _joinValueType(\n        uint256 a,\n        uint256 typeLength,\n        uint256 shiftLeft\n    ) private pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            let inputLength := mload(a)\n            let inputData := add(a, 0x20)\n            let end := add(inputData, mul(inputLength, 0x20))\n\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Initialize the length of the final bytes: length is typeLength x inputLength (array of bytes4)\n            mstore(tempBytes, mul(inputLength, typeLength))\n            let memoryPointer := add(tempBytes, 0x20)\n\n            // Iterate over all bytes4\n            for {\n                let pointer := inputData\n            } lt(pointer, end) {\n                pointer := add(pointer, 0x20)\n            } {\n                let currentSlot := shl(shiftLeft, mload(pointer))\n                mstore(memoryPointer, currentSlot)\n                memoryPointer := add(memoryPointer, typeLength)\n            }\n\n            mstore(0x40, and(add(memoryPointer, 31), not(31)))\n        }\n        return tempBytes;\n    }\n\n    function _joinReferenceType(uint256 inputPointer, uint256 gluePointer)\n        public\n        pure\n        returns (bytes memory tempBytes)\n    {\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Skip the first 32 bytes where we will store the length of the result\n            let memoryPointer := add(tempBytes, 0x20)\n\n            // Load glue\n            let glueLength := mload(gluePointer)\n            if gt(glueLength, 0x20) {\n                revert(gluePointer, 0x20)\n            }\n            let glue := mload(add(gluePointer, 0x20))\n\n            // Load the length (first 32 bytes)\n            let inputLength := mload(inputPointer)\n            let inputData := add(inputPointer, 0x20)\n            let end := add(inputData, mul(inputLength, 0x20))\n\n            // Initialize the length of the final string\n            let stringLength := 0\n\n            // Iterate over all strings (a string is itself an array).\n            for {\n                let pointer := inputData\n            } lt(pointer, end) {\n                pointer := add(pointer, 0x20)\n            } {\n                let currentStringArray := mload(pointer)\n                let currentStringLength := mload(currentStringArray)\n                stringLength := add(stringLength, currentStringLength)\n                let currentStringBytesCount := add(\n                    div(currentStringLength, 0x20),\n                    gt(mod(currentStringLength, 0x20), 0)\n                )\n\n                let currentPointer := add(currentStringArray, 0x20)\n\n                for {\n                    let copiedBytesCount := 0\n                } lt(copiedBytesCount, currentStringBytesCount) {\n                    copiedBytesCount := add(copiedBytesCount, 1)\n                } {\n                    mstore(\n                        add(memoryPointer, mul(copiedBytesCount, 0x20)),\n                        mload(currentPointer)\n                    )\n                    currentPointer := add(currentPointer, 0x20)\n                }\n                memoryPointer := add(memoryPointer, currentStringLength)\n                mstore(memoryPointer, glue)\n                memoryPointer := add(memoryPointer, glueLength)\n            }\n\n            mstore(\n                tempBytes,\n                add(stringLength, mul(sub(inputLength, 1), glueLength))\n            )\n            mstore(0x40, and(add(memoryPointer, 31), not(31)))\n        }\n        return tempBytes;\n    }\n}\n"
    },
    "contracts/lib/renderers/RendererCommons.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"@0xsequence/sstore2/contracts/SSTORE2.sol\";\n\nimport {Integers} from \"../utils/Integers.sol\";\nimport {Array} from \"../utils/Array.sol\";\n\n/**  @title BaseRenderer\n *\n *   This library contains shared functionality and constants for the renderers.\n *\n * @author Clement Walter <clement0walter@gmail.com>\n */\nlibrary RendererCommons {\n    using Integers for uint256;\n    using Integers for uint8;\n    using Array for string[];\n\n    string public constant DATA_URI = \"data:image/svg+xml,\";\n    string public constant XMLNS_HEADER =\n        \"xmlns=%27http://www.w3.org/2000/svg%27\";\n    string public constant SPACE = \"%20\";\n    string public constant QUOTE = \"%27\";\n    string public constant NUMBER_SIGN = \"%23\";\n    string public constant TAG_START = \"%3c\";\n    string public constant TAG_END = \"/%3e\";\n\n    event BytesStored(address pointer);\n\n    /**\n     * @dev Usually colors are already defined in hex color space so we just concat all the colors. No check is made\n     *      and this function only concatenates the input colors.\n     * @param palette The list of colors as hex strings, without the leading #.\n     * @return The concatenated colors as string. To be used as bytes afterwards.\n     */\n    function encodePalette(string[] memory palette)\n        public\n        pure\n        returns (string memory)\n    {\n        return string.concat(\"0x\", palette.join());\n    }\n\n    /** @dev Returns one single color reading directly from the storage.\n     * @param pointer The pointer to the palette bytes array where each color is R, G, B at storage i, i+1, i+2.\n     * @param index The index of the color to retrieve\n     * @return The hexstring representation of the color, e.g. \"a3120f\".\n     */\n    function getFill(address pointer, uint256 index)\n        public\n        view\n        returns (string memory)\n    {\n        bytes memory palette = SSTORE2.read(pointer, 3 * index, 3 * index + 3);\n\n        return\n            string.concat(\n                uint8(palette[0]).toString(16, 2),\n                uint8(palette[1]).toString(16, 2),\n                uint8(palette[2]).toString(16, 2)\n            );\n    }\n\n    /** @dev Returns one single color from a pre-loaded whole palette as a bytes array.\n     * @param palette A bytes array encoding several RGB colors. Length should be a multiple of 3.\n     * @param index The index of the color to retrieve\n     * @return The hexstring representation of the color, e.g. \"a3120f\".\n     */\n    function getFill(bytes memory palette, uint256 index)\n        public\n        pure\n        returns (string memory)\n    {\n        return\n            string.concat(\n                uint8(palette[3 * index]).toString(16, 2),\n                uint8(palette[3 * index + 1]).toString(16, 2),\n                uint8(palette[3 * index + 2]).toString(16, 2)\n            );\n    }\n\n    /** @dev Decode the whole palette once for all and returns an array of hexstrings.\n     * @param pointer The pointer to the palette bytes array where each color is at storage at i, i+1, i+2.\n     * @return An array of hexstring representation of the color, e.g. \"a3120f\".\n     */\n    function getPalette(address pointer) public view returns (string[] memory) {\n        bytes memory palette = SSTORE2.read(pointer);\n        return getPalette(palette);\n    }\n\n    function getPalette(bytes memory palette)\n        public\n        pure\n        returns (string[] memory)\n    {\n        uint256 paletteSize = palette.length / 3;\n        string[] memory paletteHex = new string[](paletteSize);\n        for (uint256 i = 0; i < paletteSize; i++) {\n            paletteHex[i] = getFill(palette, i);\n        }\n        return paletteHex;\n    }\n}\n"
    },
    "@0xsequence/sstore2/contracts/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./utils/Bytecode.sol\";\n\n/**\n  @title A key-value storage with auto-generated keys for storing chunks of data with a lower write & read cost.\n  @author Agustin Aguilar <aa@horizon.io>\n\n  Readme: https://github.com/0xsequence/sstore2#readme\n*/\nlibrary SSTORE2 {\n  error WriteError();\n\n  /**\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\n    @dev The pointer is a contract address with `_data` as code\n    @param _data to be written\n    @return pointer Pointer to the written `_data`\n  */\n  function write(bytes memory _data) internal returns (address pointer) {\n    // Append 00 to _data so contract can't be called\n    // Build init code\n    bytes memory code = Bytecode.creationCodeFor(\n      abi.encodePacked(\n        hex'00',\n        _data\n      )\n    );\n\n    // Deploy contract using create\n    assembly { pointer := create(0, add(code, 32), mload(code)) }\n\n    // Address MUST be non-zero\n    if (pointer == address(0)) revert WriteError();\n  }\n\n  /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @return data read from `_pointer` contract\n  */\n  function read(address _pointer) internal view returns (bytes memory) {\n    return Bytecode.codeAt(_pointer, 1, type(uint256).max);\n  }\n\n  /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @param _start number of bytes to skip\n    @return data read from `_pointer` contract\n  */\n  function read(address _pointer, uint256 _start) internal view returns (bytes memory) {\n    return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\n  }\n\n  /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @param _start number of bytes to skip\n    @param _end index before which to end extraction\n    @return data read from `_pointer` contract\n  */\n  function read(address _pointer, uint256 _start, uint256 _end) internal view returns (bytes memory) {\n    return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\n  }\n}\n"
    },
    "contracts/lib/utils/Integers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * Integers Library updated from https://github.com/willitscale/solidity-util\n *\n * In summary this is a simple library of integer functions which allow a simple\n * conversion to and from strings\n *\n * @author Clement Walter <clement0walter@gmail.com>\n */\nlibrary Integers {\n    /**\n     * To String\n     *\n     * Converts an unsigned integer to the string equivalent value, returned as bytes\n     * Equivalent to javascript's toString(base)\n     *\n     * @param _number The unsigned integer to be converted to a string\n     * @param _base The base to convert the number to\n     * @param  _padding The target length of the string; result will be padded with 0 to reach this length while padding\n     *         of 0 means no padding\n     * @return bytes The resulting ASCII string value\n     */\n    function toString(\n        uint256 _number,\n        uint8 _base,\n        uint8 _padding\n    ) public pure returns (string memory) {\n        uint256 count = 0;\n        uint256 b = _number;\n        while (b != 0) {\n            count++;\n            b /= _base;\n        }\n        if (_number == 0) {\n            count++;\n        }\n        bytes memory res;\n        if (_padding == 0) {\n            res = new bytes(count);\n        } else {\n            res = new bytes(_padding);\n        }\n        for (uint256 i = 0; i < res.length; ++i) {\n            b = _number % _base;\n            if (b < 10) {\n                res[res.length - i - 1] = bytes1(uint8(b + 48)); // 0-9\n            } else {\n                res[res.length - i - 1] = bytes1(uint8((b % 10) + 65)); // A-F\n            }\n            _number /= _base;\n        }\n\n        for (uint256 i = count; i < _padding; ++i) {\n            res[res.length - i - 1] = hex\"30\"; // 0\n        }\n\n        return string(res);\n    }\n\n    function toString(uint256 _number) public pure returns (string memory) {\n        return toString(_number, 10, 0);\n    }\n\n    function toString(uint256 _number, uint8 _base)\n        public\n        pure\n        returns (string memory)\n    {\n        return toString(_number, _base, 0);\n    }\n}\n"
    },
    "@0xsequence/sstore2/contracts/utils/Bytecode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\nlibrary Bytecode {\n  error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\n\n  /**\n    @notice Generate a creation code that results on a contract with `_code` as bytecode\n    @param _code The returning value of the resulting `creationCode`\n    @return creationCode (constructor) for new contract\n  */\n  function creationCodeFor(bytes memory _code) internal pure returns (bytes memory) {\n    /*\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\n      0x01    0x80         0x80        DUP1                size size\n      0x02    0x60         0x600e      PUSH1 14            14 size size\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\n      0x04    0x39         0x39        CODECOPY            size\n      0x05    0x60         0x6000      PUSH1 00            0 size\n      0x06    0xf3         0xf3        RETURN\n      <CODE>\n    */\n\n    return abi.encodePacked(\n      hex\"63\",\n      uint32(_code.length),\n      hex\"80_60_0E_60_00_39_60_00_F3\",\n      _code\n    );\n  }\n\n  /**\n    @notice Returns the size of the code on a given address\n    @param _addr Address that may or may not contain code\n    @return size of the code on the given `_addr`\n  */\n  function codeSize(address _addr) internal view returns (uint256 size) {\n    assembly { size := extcodesize(_addr) }\n  }\n\n  /**\n    @notice Returns the code of a given address\n    @dev It will fail if `_end < _start`\n    @param _addr Address that may or may not contain code\n    @param _start number of bytes of code to skip on read\n    @param _end index before which to end extraction\n    @return oCode read from `_addr` deployed bytecode\n\n    Forked from: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\n  */\n  function codeAt(address _addr, uint256 _start, uint256 _end) internal view returns (bytes memory oCode) {\n    uint256 csize = codeSize(_addr);\n    if (csize == 0) return bytes(\"\");\n\n    if (_start > csize) return bytes(\"\");\n    if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end); \n\n    unchecked {\n      uint256 reqSize = _end - _start;\n      uint256 maxSize = csize - _start;\n\n      uint256 size = maxSize < reqSize ? maxSize : reqSize;\n\n      assembly {\n        // allocate output byte array - this could also be done without assembly\n        // by using o_code = new bytes(size)\n        oCode := mload(0x40)\n        // new \"memory end\" including padding\n        mstore(0x40, add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n        // store length in memory\n        mstore(oCode, size)\n        // actually retrieve the code, this needs assembly\n        extcodecopy(_addr, add(oCode, 0x20), _start, size)\n      }\n    }\n  }\n}\n"
    },
    "contracts/lib/renderers/RectRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.12;\n\nimport \"@0xsequence/sstore2/contracts/SSTORE2.sol\";\n\nimport {Integers} from \"../utils/Integers.sol\";\nimport {Bytes} from \"../utils/Bytes.sol\";\nimport {Array} from \"../utils/Array.sol\";\n\nerror InvalidLength(uint256 length);\nerror CharacteristicOutOfRange(uint256 characteristic);\nerror TraitOutOfRange(uint256 trait);\n\n/**  @title RectRenderer\n *\n *   This library can be used to render on-chain images stored as a layering of rectangles.\n *   The returned images is an url safe encoded image uri.\n *\n * @author Clement Walter <clement0walter@gmail.com>\n */\nlibrary RectRenderer {\n    using Integers for uint8;\n    using Integers for uint256;\n    using Bytes for bytes;\n    using Array for string[];\n\n    string public constant RECT_TAG_START = \"%3crect%20x=%27\";\n    string public constant Y_TAG = \"%27%20y=%27\";\n    string public constant WIDTH_TAG = \"%27%20width=%27\";\n    string public constant HEIGHT_TAG = \"%27%20height=%27\";\n    string public constant FILL_TAG = \"%27%20fill=%27%23\";\n    string public constant RECT_TAG_END = \"%27/%3e\";\n\n    /** @dev Retrieve the bytes for the given trait from the traits storage.\n     *  @param pointer The pointer to the traits stored with SSTORE2.\n     *  @param characteristicIndex The index of the characteristic in the collection.\n     *  @param traitIndex The index of the trait in the characteristic.\n     *  @return The bytes of the trait.\n     */\n    function getTraitBytes(\n        address pointer,\n        uint256 characteristicIndex,\n        uint256 traitIndex\n    ) public view returns (bytes memory) {\n        uint16 characteristicsLength = SSTORE2.read(pointer, 0, 2).toUint16();\n\n        if (characteristicsLength - 1 < characteristicIndex)\n            revert CharacteristicOutOfRange(characteristicIndex);\n        uint16 characteristicStart = SSTORE2\n            .read(\n                pointer,\n                2 + 2 * characteristicIndex,\n                2 + 2 * characteristicIndex + 2\n            )\n            .toUint16();\n        uint16 traitsLength = SSTORE2\n            .read(pointer, characteristicStart, characteristicStart + 2)\n            .toUint16() - 1;\n        if (traitsLength - 1 < traitIndex) revert TraitOutOfRange(traitIndex);\n        bytes memory _indexes = SSTORE2.read(\n            pointer,\n            characteristicStart + 2 + 2 * traitIndex,\n            characteristicStart + 2 + 2 * traitIndex + 4\n        );\n        return\n            SSTORE2.read(\n                pointer,\n                characteristicStart + _indexes.toUint16(0),\n                characteristicStart + _indexes.toUint16(2)\n            );\n    }\n\n    function decodeBytes4ToRect(bytes4 rectBytes, string[] memory palette)\n        public\n        pure\n        returns (string memory)\n    {\n        return decodeBytes4ToRect(rectBytes, palette, 0, 0);\n    }\n\n    function decodeBytes4ToRect(\n        bytes4 rectBytes,\n        string[] memory palette,\n        uint256 offsetX,\n        uint256 offsetY\n    ) public pure returns (string memory) {\n        return\n            string.concat(\n                RECT_TAG_START,\n                (uint8(uint32(rectBytes >> 26)) + offsetX).toString(),\n                Y_TAG,\n                ((uint8(uint32(rectBytes >> 20)) & 0x3f) + offsetY).toString(),\n                WIDTH_TAG,\n                (uint8(uint32(rectBytes >> 14)) & 0x3f).toString(),\n                HEIGHT_TAG,\n                (uint8(uint32(rectBytes >> 8)) & 0x3f).toString(),\n                FILL_TAG,\n                palette[uint8(rectBytes[3])],\n                RECT_TAG_END\n            );\n    }\n\n    function decodeBytesMemoryToRects(\n        bytes memory rectsBytes,\n        string[] memory palette\n    ) public pure returns (string memory) {\n        if (rectsBytes.length % 4 != 0) {\n            revert InvalidLength(rectsBytes.length);\n        }\n        uint256 nbRects = rectsBytes.length / 4;\n        string[] memory rects = new string[](nbRects);\n        for (uint256 i = 0; i < rects.length; i++) {\n            rects[i] = decodeBytes4ToRect(rectsBytes.toBytes4(i * 4), palette);\n        }\n        return rects.join();\n    }\n}\n"
    },
    "contracts/lib/utils/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Clement Walter <clement0walter@gmail.com> from Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary Bytes {\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) public pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(\n                    add(tempBytes, lengthmod),\n                    mul(0x20, iszero(lengthmod))\n                )\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(\n                        add(\n                            add(_bytes, lengthmod),\n                            mul(0x20, iszero(lengthmod))\n                        ),\n                        _start\n                    )\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (address tmp)\n    {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n\n        assembly {\n            tmp := div(\n                mload(add(add(_bytes, 0x20), _start)),\n                0x1000000000000000000000000\n            )\n        }\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (uint8 tmp)\n    {\n        require(_bytes.length >= _start + 1, \"toUint8_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x1), _start))\n        }\n    }\n\n    function toBytes1(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (bytes1 tmp)\n    {\n        require(_bytes.length >= _start + 1, \"toBytes1_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x1), _start))\n        }\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (uint16 tmp)\n    {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x2), _start))\n        }\n    }\n\n    function toUint16(bytes memory _bytes) public pure returns (uint16 tmp) {\n        return toUint16(_bytes, 0);\n    }\n\n    function toBytes2(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (bytes2 tmp)\n    {\n        require(_bytes.length >= _start + 2, \"toBytes2_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x2), _start))\n        }\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (uint24 tmp)\n    {\n        require(_bytes.length >= _start + 3, \"toUint24_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x3), _start))\n        }\n    }\n\n    function toBytes3(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (bytes3 tmp)\n    {\n        require(_bytes.length >= _start + 3, \"toBytes3_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x3), _start))\n        }\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (uint32 tmp)\n    {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x4), _start))\n        }\n    }\n\n    function toBytes4(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (bytes4 tmp)\n    {\n        require(_bytes.length >= _start + 4, \"toBytes4_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x4), _start))\n        }\n    }\n\n    function toUint40(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (uint40 tmp)\n    {\n        require(_bytes.length >= _start + 5, \"toUint40_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x5), _start))\n        }\n    }\n\n    function toBytes5(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (bytes5 tmp)\n    {\n        require(_bytes.length >= _start + 5, \"toBytes5_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x5), _start))\n        }\n    }\n\n    function toUint48(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (uint48 tmp)\n    {\n        require(_bytes.length >= _start + 6, \"toUint48_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x6), _start))\n        }\n    }\n\n    function toBytes6(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (bytes6 tmp)\n    {\n        require(_bytes.length >= _start + 6, \"toBytes6_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x6), _start))\n        }\n    }\n\n    function toUint56(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (uint56 tmp)\n    {\n        require(_bytes.length >= _start + 7, \"toUint56_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x7), _start))\n        }\n    }\n\n    function toByes7(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (bytes7 tmp)\n    {\n        require(_bytes.length >= _start + 7, \"toBytes7_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x7), _start))\n        }\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (uint64 tmp)\n    {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x8), _start))\n        }\n    }\n\n    function toBytes8(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (uint64 tmp)\n    {\n        require(_bytes.length >= _start + 8, \"toBytes8_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x8), _start))\n        }\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (uint96 tmp)\n    {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0xc), _start))\n        }\n    }\n\n    function toBytes12(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (bytes12 tmp)\n    {\n        require(_bytes.length >= _start + 12, \"toBytes12_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0xc), _start))\n        }\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (uint128 tmp)\n    {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x10), _start))\n        }\n    }\n\n    function toBytes16(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (bytes12 tmp)\n    {\n        require(_bytes.length >= _start + 16, \"toBytes16_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x10), _start))\n        }\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (uint256 tmp)\n    {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x20), _start))\n        }\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start)\n        public\n        pure\n        returns (bytes32 tmp)\n    {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n\n        assembly {\n            tmp := mload(add(add(_bytes, 0x20), _start))\n        }\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes)\n        public\n        pure\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes)\n        public\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(\n                and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)),\n                2\n            )\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {\n\n                        } eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "contracts/tokens/ERC721BEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ERC721B} from \"./ERC721B.sol\";\nimport {IERC721Enumerable} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Bytes} from \"../lib/utils/Bytes.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token optimized for batch minting with enumerable interface\n * @notice a bytes2 (uint16) is used to store the token id so the collection should be lower than 2^16 = 65536 items\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n *      Based on the study for writing indexes and addresses, we use a single mapping for storing all the data\n *      We use the uint16 / bytes2 tokenId\n */\ncontract ERC721BEnumerable is ERC721B, IERC721Enumerable {\n    using Bytes for bytes;\n\n    function totalSupply() external view override returns (uint256) {\n        uint256 total = 0;\n        for (uint256 i = 0; i < owners.length; i += 20) {\n            total += _balanceOf(i);\n        }\n        return total;\n    }\n\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        external\n        view\n        override\n        returns (uint256 tokenId)\n    {\n        require(\n            index * 2 < _tokensByOwner[owner].length,\n            \"ERC721Enumerable: index out of range\"\n        );\n        return _tokensByOwner[owner].toUint16(index * 2);\n    }\n\n    function tokenByIndex(uint256 index)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 ownerIndex = 0;\n        uint256 count;\n        while (count <= index) {\n            count += _balanceOf(ownerIndex);\n            ownerIndex += 20;\n        }\n        ownerIndex -= 20;\n        count -= _balanceOf(ownerIndex);\n        return\n            _tokensByOwner[owners.toAddress(ownerIndex)].toUint16(\n                (index - count) * 2\n            );\n    }\n\n    constructor(string memory name_, string memory symbol_)\n        ERC721B(name_, symbol_)\n    {}\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(IERC165, ERC721B)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/tokens/ERC721B.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {Bytes} from \"../lib/utils/Bytes.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token optimized for batch minting\n * @notice a bytes2 (uint16) is used to store the token id so the collection should be lower than 2^16 = 65536 items\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n *      Based on the study for writing indexes and addresses, we use a single mapping for storing all the data\n *      We use the uint16 / bytes2 tokenId\n */\ncontract ERC721B is IERC721, IERC721Metadata, Context, ERC165 {\n    using Address for address;\n    using Bytes for bytes;\n\n    // Mapping from address to tokenIds. This is the single source of truth for the data\n    mapping(address => bytes) internal _tokensByOwner;\n\n    // Because mapping in solidity are not real hash tables, one needs to keep track of the keys.\n    // One address is 20 bytes\n    bytes internal owners;\n\n    // Number of tokens\n    uint16 public constant MAX_NUMBER_OF_TOKENS = 10_000;\n\n    // Bool array to store if the token is minted. To save on gas for token lookup in _tokensByOwner.\n    bool[MAX_NUMBER_OF_TOKENS] public tokenExists;\n\n    // Mapping from token ID to approved address\n    mapping(uint16 => address) internal _tokenApprovals;\n\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev There are two bytes per tokenId\n     * @param owner address The address we retrieve the balance for\n     * @return uint256 The number of tokens owned by the address\n     */\n    function balanceOf(address owner) public view override returns (uint256) {\n        return _tokensByOwner[owner].length / 2;\n    }\n\n    /// @dev Returns the balance of the owner at index ownerIndex in the internal owners array\n    /// @param ownerIndex uint256 The index of the owner in the internal owners array\n    /// @return uint256 The number of tokens owned by the address\n    function _balanceOf(uint256 ownerIndex) internal view returns (uint256) {\n        require(\n            ownerIndex * 20 < owners.length,\n            \"ERC721B: ownerIndex out of bound\"\n        );\n        return balanceOf(owners.toAddress(ownerIndex * 20));\n    }\n\n    /// @dev Returns the index of owner in the internal array of owners. Revert if not found.\n    /// @param owner address The address we retrieve the index for\n    /// @return uint256 The index of the owner in the internal owners array\n    function getOwnerIndex(address owner) external view returns (uint256) {\n        uint256 index = 0;\n        while (index < owners.length) {\n            if (owners.toAddress(index) == owner) {\n                return index / 20;\n            }\n            index += 20;\n        }\n        revert(\"ERC721B: Owner not found\");\n    }\n\n    /// @dev Returns the array of bool telling if a token exists or not.\n    function getTokenExists()\n        external\n        view\n        returns (bool[MAX_NUMBER_OF_TOKENS] memory)\n    {\n        return tokenExists;\n    }\n\n    /**\n     * @param tokenId uint16 A given token id\n     * @return bool True if the token exists, false otherwise\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return tokenExists[tokenId];\n    }\n\n    /**\n     * @dev This is copied from OpenZeppelin's implementation\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try\n                IERC721Receiver(to).onERC721Received(\n                    _msgSender(),\n                    from,\n                    tokenId,\n                    _data\n                )\n            returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\n                        \"ERC721B: transfer to non ERC721Receiver implementer\"\n                    );\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /// @dev This is the core unsafe implementation of a transfer.\n    /// @param from address The address which you want to transfer the token from\n    /// @param fromIndex uint256 The index of \"from\" in the owners bytes. This is to avoid a search in the array.\n    /// @param to address The address which you want to transfer the token to\n    /// @param tokenIndex uint256 The index of the token to transfer in the from's token list.\n    function _transfer(\n        address from,\n        uint256 fromIndex,\n        address to,\n        uint256 tokenIndex\n    ) private {\n        if (_tokensByOwner[to].length == 0) {\n            owners = bytes.concat(owners, bytes20(to));\n        }\n        bytes memory tokenId = _tokensByOwner[from].slice(\n            tokenIndex,\n            tokenIndex + 2\n        );\n        if (_tokensByOwner[from].length == 2) {\n            require(\n                owners.toAddress(fromIndex * 20) == from,\n                \"ERC721B: transfer from address is invalid\"\n            );\n            owners = bytes.concat(\n                owners.slice(0, fromIndex * 20),\n                owners.slice(\n                    (fromIndex + 1) * 20,\n                    owners.length - (fromIndex + 1) * 20\n                )\n            );\n            delete _tokensByOwner[from];\n        } else {\n            _tokensByOwner[from] = bytes.concat(\n                _tokensByOwner[from].slice(0, tokenIndex),\n                _tokensByOwner[from].slice(\n                    tokenIndex + 2,\n                    _tokensByOwner[from].length - tokenIndex - 2\n                )\n            );\n        }\n        _tokensByOwner[to] = bytes.concat(_tokensByOwner[to], tokenId);\n        emit Transfer(from, to, tokenId.toUint16(0));\n    }\n\n    /// @dev Transfer token with minimal computing since all the required data to check is given\n    /// @param from address The address which you want to transfer the token from\n    /// @param fromIndex uint256 The index of \"from\" in the owners bytes. This is to avoid a search in the array.\n    /// @param to address The address which you want to transfer the token to\n    /// @param tokenIndex uint256 The index of the token to transfer in the from's token list.\n    function safeTransferFrom(\n        address from,\n        uint256 fromIndex,\n        address to,\n        uint256 tokenIndex\n    ) external {\n        require(from != address(0), \"ERC721B: from cannot be the zero address\");\n        require(to != address(0), \"ERC721B: to cannot be the zero address\");\n        require(\n            tokenIndex < _tokensByOwner[from].length / 2,\n            \"ERC721B: token index out of range\"\n        );\n        uint16 tokenId = _tokensByOwner[from].toUint16(tokenIndex * 2);\n        require(\n            _isApproved(_msgSender(), tokenId) || from == _msgSender(),\n            \"ERC721B: transfer caller is not owner nor approved\"\n        );\n        _transfer(from, fromIndex, to, tokenIndex);\n        _checkOnERC721Received(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev This is the core unsafe implementation of a mint.\n     * @param to address The receiver of the tokens\n     * @param tokenIds bytes The token ids to mint\n     */\n    function _mintBatch(address to, bytes calldata tokenIds) private {\n        require(tokenIds.length > 0, \"ERC721B: cannot mint with no token Ids\");\n        require(\n            tokenIds.length % 2 == 0,\n            \"ERC721B: tokenIds should be bytes of uint16\"\n        );\n        if (_tokensByOwner[to].length == 0) {\n            owners = bytes.concat(owners, bytes20(to));\n        }\n        for (uint256 i = 0; i < tokenIds.length; i += 2) {\n            require(\n                !tokenExists[tokenIds.toUint16(i)],\n                \"ERC721B: token already exists\"\n            );\n            tokenExists[tokenIds.toUint16(i)] = true;\n            emit Transfer(address(0), to, tokenIds.toUint16(i));\n        }\n        _tokensByOwner[to] = bytes.concat(_tokensByOwner[to], tokenIds);\n    }\n\n    /// @dev Add a batch of token Ids given as a bytes array to the sender\n    /// @param tokenIds bytes a bytes of tokenIds as bytes2 (uint16)\n    function safeMintBatch(bytes calldata tokenIds) public {\n        _mintBatch(_msgSender(), tokenIds);\n        _checkOnERC721Received(\n            address(0),\n            _msgSender(),\n            tokenIds.toUint16(0),\n            \"\"\n        );\n    }\n\n    /// @dev Approve \"to\" to manage token Id\n    /// @param to address The address which will manage the token Id\n    /// @param tokenId uint256 The token Id to manage\n    /// @param tokenIndex uint256 The index of the token in the owner's list\n    function approve(\n        address to,\n        uint256 tokenId,\n        uint256 tokenIndex\n    ) external {\n        if (_tokenApprovals[uint16(tokenId)] != _msgSender()) {\n            // if sender is not approved, they need to be the owner\n            require(\n                tokenIndex * 2 < _tokensByOwner[_msgSender()].length,\n                \"ERC721B: token index out of range\"\n            );\n            require(\n                _tokensByOwner[_msgSender()].toUint16(tokenIndex * 2) ==\n                    tokenId,\n                \"ERC721B: caller is neither approved nor owner\"\n            );\n            emit Approval(_msgSender(), to, tokenId);\n        }\n        _tokenApprovals[uint16(tokenId)] = to;\n    }\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId)\n        public\n        view\n        override\n        returns (address)\n    {\n        require(_exists(tokenId), \"ERC721B: token does not exist\");\n        return _tokenApprovals[uint16(tokenId)];\n    }\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     * @param operator The address of the operator to add or remove.\n     * @param _approved Whether to add or remove `operator` as an operator.\n     */\n    function setApprovalForAll(address operator, bool _approved)\n        external\n        override\n    {\n        require(\n            operator != _msgSender(),\n            \"ERC721B: cannot approve caller as operator\"\n        );\n        bytes memory tokens = _tokensByOwner[_msgSender()];\n        for (uint256 i = 0; i < tokens.length; i += 2) {\n            _tokenApprovals[tokens.toUint16(i)] = _approved\n                ? operator\n                : address(0);\n        }\n\n        emit ApprovalForAll(_msgSender(), operator, _approved);\n    }\n\n    /**\n     * @dev Returns whether `operator` is an approved operator for the caller.\n     * @param owner The address of the owner to check.\n     * @param operator The address of the operator to check.\n     */\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        bytes memory tokens = _tokensByOwner[owner];\n        for (uint256 i = 0; i < tokens.length; i += 2) {\n            if (_tokenApprovals[tokens.toUint16(i)] != operator) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @dev Overwrite this function to add some other approval logic, for instance for OpenSea.\n    function _isApproved(address spender, uint256 tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return getApproved(tokenId) == spender;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // Functions that should not be used but here for compatibility with ERC721\n    // These are gassy.\n    ///////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal {\n        require(from != address(0), \"ERC721B: from cannot be the zero address\");\n        require(to != address(0), \"ERC721B: to cannot be the zero address\");\n        require(\n            _isApproved(_msgSender(), tokenId) || from == _msgSender(),\n            \"ERC721B: transfer caller is not owner nor approved\"\n        );\n        uint256 tokenIndex = 0;\n        while (\n            _tokensByOwner[from].toUint16(tokenIndex) != tokenId &&\n            tokenIndex < _tokensByOwner[from].length\n        ) {\n            tokenIndex += 2;\n        }\n        require(\n            tokenIndex < _tokensByOwner[from].length,\n            \"ERC721B: from does not own the token\"\n        );\n\n        uint256 fromIndex;\n        if (_tokensByOwner[from].length == 2) {\n            // A bit hacky but this is to avoid a useless computation for this gassy implementation\n            for (fromIndex = 0; fromIndex < owners.length; fromIndex += 20) {\n                if (owners.toAddress(fromIndex) == from) {\n                    break;\n                }\n            }\n            require(\n                owners.toAddress(fromIndex) == from,\n                \"ERC721B: from is not in owners list\"\n            );\n        }\n        _transfer(from, fromIndex, to, tokenIndex);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external override {\n        _safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external override {\n        _safeTransferFrom(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external override {\n        require(from != address(0), \"ERC721B: from cannot be the zero address\");\n        require(to != address(0), \"ERC721B: to cannot be the zero address\");\n        require(\n            _isApproved(_msgSender(), tokenId),\n            \"ERC721B: transfer caller is not owner nor approved\"\n        );\n        uint256 tokenIndex = 0;\n        while (\n            _tokensByOwner[from].toUint16(tokenIndex) != tokenId &&\n            tokenIndex < _tokensByOwner[from].length\n        ) {\n            tokenIndex += 2;\n        }\n        require(\n            tokenIndex < _tokensByOwner[from].length,\n            \"ERC721B: from does not own the token\"\n        );\n\n        uint256 fromIndex;\n        if (_tokensByOwner[from].length == 2) {\n            // A bit hacky but this is to avoid a useless computation for this gassy implementation\n            for (fromIndex = 0; fromIndex < owners.length; fromIndex += 20) {\n                if (owners.toAddress(fromIndex) == from) {\n                    break;\n                }\n            }\n            require(\n                owners.toAddress(fromIndex) == from,\n                \"ERC721B: from is not in owners list\"\n            );\n        }\n        _transfer(from, fromIndex, to, tokenIndex);\n    }\n\n    /**\n     * @dev Returns true of owner is the owner of the given token.\n     *      This is much less gassy than using address == ownerOf(tokenId).\n     * @param owner address The asserted owner\n     * @param tokenId uint16 A given token id\n     * @return bool True if the owner is truly the owner of the token\n     */\n    function _isOwnerOf(address owner, uint256 tokenId)\n        private\n        view\n        returns (bool)\n    {\n        for (uint256 j = 0; j < _tokensByOwner[owner].length; j += 2) {\n            if (_tokensByOwner[owner].toUint16(j) == tokenId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev For each owner, we go through all their tokens and check if the sought token is in the list. This lookup\n     *      is gassy but we do not expect to pay them often as we provide other mean of doing the transfers.\n     * @param tokenId uint16 A given token id\n     * @return address The owner of the token, might be 0x0 if not found\n     */\n    function _ownerOf(uint256 tokenId) private view returns (address) {\n        address owner = address(0);\n        for (uint256 i = 0; i < owners.length; i += 20) {\n            address currentOwner = owners.toAddress(i);\n            bool isOwner = _isOwnerOf(currentOwner, tokenId);\n            if (isOwner) {\n                owner = currentOwner;\n                break;\n            }\n        }\n        return owner;\n    }\n\n    /**\n     * @dev This is the public ownerOf, see IERC721. We fail fast with the initial check. There is no good\n     *      reason to call this function on chain.\n     * @param tokenId uint265 A given token id\n     * @return address The owner of the token.\n     */\n    function ownerOf(uint256 tokenId) external view override returns (address) {\n        require(_exists(tokenId), \"ERC721B: owner query for nonexistent token\");\n        return _ownerOf(tokenId);\n    }\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external override {\n        address owner = _ownerOf(tokenId);\n        require(\n            owner != address(0),\n            \"ERC721B: approve query for nonexistent token\"\n        );\n        require(\n            _tokenApprovals[uint16(tokenId)] == _msgSender() ||\n                owner == _msgSender(),\n            \"ERC721B: caller is not the owner nor an approved operator for the token\"\n        );\n        _tokenApprovals[uint16(tokenId)] = to;\n        emit Approval(owner, to, tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/test_utils/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@0xsequence/sstore2/contracts/utils/Bytecode.sol\";\n\n/**\n  @title A key-value storage with auto-generated keys for storing chunks of data with a lower write & read cost.\n  @author Agustin Aguilar <aa@horizon.io>\n  @notice This is the exact same code but a contract with public instead of internal visibility.\n\n  Readme: https://github.com/0xsequence/sstore2#readme\n*/\ncontract SSTORE2 {\n    error WriteError();\n\n    event Write(address pointer);\n\n    /**\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\n    @dev The pointer is a contract address with `_data` as code\n    @param _data to be written\n    @return pointer Pointer to the written `_data`\n  */\n    function write(bytes memory _data) public returns (address pointer) {\n        // Append 00 to _data so contract can't be called\n        // Build init code\n        bytes memory code = Bytecode.creationCodeFor(\n            abi.encodePacked(hex\"00\", _data)\n        );\n\n        // Deploy contract using create\n        assembly {\n            pointer := create(0, add(code, 32), mload(code))\n        }\n\n        // Address MUST be non-zero\n        if (pointer == address(0)) revert WriteError();\n\n        emit Write(pointer);\n    }\n\n    /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte\n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @return data read from `_pointer` contract\n  */\n    function read(address _pointer) public view returns (bytes memory) {\n        return Bytecode.codeAt(_pointer, 1, type(uint256).max);\n    }\n\n    /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte\n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @param _start number of bytes to skip\n    @return data read from `_pointer` contract\n  */\n    function read(address _pointer, uint256 _start)\n        public\n        view\n        returns (bytes memory)\n    {\n        return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\n    }\n\n    /**\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte\n    @dev The function is intended for reading pointers generated by `write`\n    @param _pointer to be read\n    @param _start number of bytes to skip\n    @param _end index before which to end extraction\n    @return data read from `_pointer` contract\n  */\n    function read(\n        address _pointer,\n        uint256 _start,\n        uint256 _end\n    ) public view returns (bytes memory) {\n        return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true,
          "optimizerSteps": "dhfoDgvulfnTUtnIf"
        }
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}